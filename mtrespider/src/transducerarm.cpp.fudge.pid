// Includes
#include "ros/ros.h"
#include "std_msgs/Bool.h"
#include "std_msgs/Float32.h"
#include "mtrespider/ina219.h"
#include <wiringPi.h>
#include <iostream>
#include <string>
#include <PIDController.h>

// Constants
#define ARM_UP true // Transducer arm is lifted up 
#define ARM_DOWN false // Transducer arm is in contact with the pipe surface

#define SPRING_L 8.04672 // Moment arm length in cm
#define SPOOL_R 0.635 // Motor spool radius in cm
#define MOTOR_V 1.5959

using namespace std;

// Initialize variables
bool positionSetpoint = ARM_DOWN; // Desired transducer arm position
float forceSetpoint = 1.25; // Desired normal force acting on transducer
int lastPwmDuty = -2000;
float busVoltage = 12;
float motorCurrent = 0;
double currentPos = 0;
PIDController* posCtrl = new PIDController(1023,2,0,-1023,1023);
ros::WallTime lastTime;
ros::WallTimer pidTimer;

void setPwmDuty(int duty);

// This runs when a new position setpoint has been published on the 
// /mtrespider/transducerarm/position_setpoint topic.
void positionSetpointCallback(const std_msgs::Bool::ConstPtr& msg) {
	positionSetpoint = msg->data; // Update variable with new desired position
    
    if(positionSetpoint == ARM_UP) {
        posCtrl->targetSetpoint(2.5);
    }
    else if(positionSetpoint == ARM_DOWN) {
        posCtrl->targetSetpoint(0);
    }
}

// This runs when a new force setpoint has been published on the 
// /mtrespider/transducerarm/force_setpoint topic.
void forceSetpointCallback(const std_msgs::Float32::ConstPtr& msg) {
	forceSetpoint = msg->data; // Update variable with new force setpoint
    if(positionSetpoint == ARM_DOWN) {
        posCtrl->targetSetpoint(0);
    }   
}

void setPwmDuty(int duty) {
    if(duty < -1023) {
        duty = -1023;
    }
    else if(duty > 1023) {
        duty = 1023;
    }
    
    if(!(duty == lastPwmDuty)) {
        lastPwmDuty = duty;
        if(duty < 0) {
            digitalWrite(21, LOW);
            digitalWrite(22, HIGH);
            duty = -1*duty;
        }
        else if(duty > 0) {
            digitalWrite(21, HIGH);
            digitalWrite(22, LOW);
        }
        else {
            digitalWrite(21, HIGH);
            digitalWrite(22, HIGH);
            duty = 1023;
        }
        stringstream ss;
        ss << duty;
        string str = "echo " + ss.str() + " > /sys/devices/pwm-ctrl.42/duty0";
        system(str.c_str());
    }
}

/*void ina219Callback(const mtrespider::ina219::ConstPtr& msg) {
    busVoltage = msg->voltage;
    motorCurrent = msg->current;
}
*/

void pidCallback(const ros::WallTimerEvent& event) { 
    double vel;
    //if(abs(lastPwmDuty) < 442) {
    //    vel = 0;
    //}
    //else {
        vel = 0.0023*lastPwmDuty; //+ 0.3959;
    //}
    ros::WallTime currentTime = ros::WallTime::now();
    currentPos = currentPos + vel*(currentTime.toSec() - lastTime.toSec());
    int corr = posCtrl->calc(currentPos);
    /*
    if(corr > 0) {
        setPwmDuty(corr + 441);
    }
    else if(corr < 0) {
        setPwmDuty(corr - 441);
    }
    else {
    */
        setPwmDuty(corr);
    //}
    lastTime = currentTime;   
}   

int main(int argc, char **argv)
{
	// GPIO library setup function
	wiringPiSetup();
	
	// Configure 3A motor driver pin
	pinMode(21, OUTPUT); 
	digitalWrite(21, LOW);
	
	// Configure 4A motor driver pin
	pinMode(22, OUTPUT);
	digitalWrite(22, LOW);
	
	// Configure 3-4 EN motor driver pin with Pulse Width Modulation (PWM)
	system("sudo modprobe pwm-meson; sudo modprobe pwm-ctrl"); // Enable hardware PWM drivers
	setPwmDuty(0); // Init to 0% duty (0 A current)
	system("echo 1023 > /sys/devices/pwm-ctrl.42/freq0"); // 25 kHz pulse frequency
	system("echo 1 > /sys/devices/pwm-ctrl.42/enable0"); // Enable PWM

    //ROS node init and NodeHandle init
    ros::init(argc, argv, "transducerarm");
    ros::NodeHandle n = ros::NodeHandle("transducerarm");

    // Subscribers
    ros::Subscriber positionSetpointSub = n.subscribe("position_setpoint",1, positionSetpointCallback);
    ros::Subscriber forceSetpointSub = n.subscribe("force_setpoint",1, forceSetpointCallback);
    //ros::Subscriber ina219Sub = n.subscribe("samples",1, ina219Callback);    

    // Publishers
    ros::Publisher currentPositionPub = n.advertise<std_msgs::Bool>("position_current", 1);
    std_msgs::Bool currentPositionMsg;
    currentPositionMsg.data = positionSetpoint;
    
    posCtrl->on();
    posCtrl->targetSetpoint(0);

    // Send motor control signals at a 20 Hz rate
    lastTime = ros::WallTime::now();
    pidTimer = n.createWallTimer(ros::WallDuration(0.001), pidCallback);

    ros::Rate loopRate(20);

	// Main loop
    while(ros::ok())
    {	               
        cout << "Current Position: " << currentPos << " cm" << endl;
        cout << "Target Position: " << posCtrl->getSetpoint() << " cm" << endl << endl;

        // Publish current position so HMI knows what the arm is doing
		currentPositionMsg.data = positionSetpoint;
		currentPositionPub.publish(currentPositionMsg);
		
        // Sleep for 0.05 s
        ros::spinOnce();
        loopRate.sleep();
    }
    
    // Disable motor on exit to avoid damaging anything
    system("echo 0 > /sys/devices/pwm-ctrl.42/enable0");
    digitalWrite(21, LOW);
	digitalWrite(22, LOW);
    system("sudo modprobe -r pwm-ctrl; sudo modprobe -r pwm-meson");
	
    return 0;
}
